package main

import (
	"testing"

	testing2 "github.com/KompiTech/fabric-cc-core/v2/internal/testing"
	. "github.com/KompiTech/fabric-cc-core/v2/pkg/testing"
	"github.com/KompiTech/rmap"

	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
)

// this func is entrypoint for Ginkgo tests from standard go testing
func Test(t *testing.T) {
	// make sure the Docker container handling CouchDB is ready
	testing2.InitializeCouchDBContainer()

	RegisterFailHandler(Fail)
	RunSpecs(t, "sample 01-library tests")
}

var _ = Describe("Library example tests", func() {
	var tctx *TestContext

	BeforeEach(func() {
		// use the configuration defined in main.go
		tctx = NewTestContext("sample-01-library", GetConfiguration(), nil, nil)

		// generate chaincode init payload from asset and singleton definition
		// also automatically adds superUser as default init_manager for mocked chaincode
		tctx.InitOk(tctx.GetInit("../asset", "../singleton").Bytes())

		// calls identityAddMe for each actor
		// actors in tests are fully contained and independent from any actual Fabric actors and their crypto material
		// following actor names are provided:
		// - superUser (always has superUser role granted)
		// - ordinaryUser
		// - nobodyUser
		// after calling RegisterAllActors, superUser role is set as current
		tctx.RegisterAllActors()
	})

	Describe("Asset tests", func() {
		It("Should be able to create an Author", func() {
			authorName := "Edgar Allan Poe"

			// Rmap is just a wrapper around map[string]interface{}. It provides convenience methods seen later.
			// use .Mapa to access underlying map
			authorData := rmap.NewFromMap(map[string]interface{}{
				"name": authorName,
			})

			// use tctx.Rmap method to call some chaincode method and immediately get result parsed as Rmap
			// if chaincode returns any errors, test will fail
			// TODO add router DOC
			createdAuthor := tctx.Rmap("assetCreate", "author", authorData.Bytes(), -1, "")

			// use .Mapa to be able to use standard Gomega matchers
			Expect(createdAuthor.Mapa).To(HaveKeyWithValue("name", authorName))
		})

		It("Should return error if Author does not contain required 'name' field", func() {
			authorData := rmap.NewFromMap(map[string]interface{}{
				"full_name": "Edgar Allan Poe", // note, that this object will not satisfy Author JSONSchema
			})

			// use tctx.Error method when expecting error to be returned from chaincode
			// first param contains the error message to be asserted (it suffices for message to be contained in chaincode error message, there can be extra data at start/end of the string)
			// if chaincode does not return error of error message is not matched, test will fail
			tctx.Error(`"name" value is required`, "assetCreate", "author", authorData.Bytes(), -1, "")
		})

		It("Should return error if Book contains ref to non-existent Author ID", func() {
			// all tests always start with empty state, so Author created in previous tests is not available here
			// lets check validation of invalid reference to Author
			bookData := rmap.NewFromMap(map[string]interface{}{
				"name": "The Raven",

				// Author with this UUID does not exist, so we expect reference validation to fail
				// also note, it is important to ALWAYS use []interface{} when defining literal arrays like this in Go
				// if you use []string, then issues will occur with schema validation/generic Rmap functionality
				"authors": []interface{}{"92ba6be0-d496-13d0-ccca-18e808ac60b6"},
			})

			// we are expecting ref validation to fail
			tctx.Error(`Referenced asset 'author' with ID '92ba6be0-d496-13d0-ccca-18e808ac60b6' not found`, "assetCreate", "book", bookData.Bytes(), -1, "")
		})

		It("Should be able to create Author and reference it in Book", func() {
			authorName := "Edgar Allan Poe"
			authorData := rmap.NewFromMap(map[string]interface{}{
				"name": authorName,
			})

			createdAuthor := tctx.Rmap("assetCreate", "author", authorData.Bytes(), -1, "")

			// since we are using autogenerated UUID for each asset (last argument to assetCreate is ""), we need to extract this UUID to use inside reference
			// you can use MustGet* methods in Rmap instance to get them easily
			// however, if any error occurs (key does not exist, or has invalid type), the code will panic, so do not use this in production environment - use the variant without Must, which returns error
			authorID := createdAuthor.MustGetString("uuid")

			bookName := "The Raven"
			bookData := rmap.NewFromMap(map[string]interface{}{
				"name":    bookName,
				"authors": []interface{}{authorID},
			})

			createdBook := tctx.Rmap("assetCreate", "book", bookData.Bytes(), -1, "")

			// asset returned by assetCreate method will always be in unresolved form ("authors" array will contain the foreign key)
			Expect(createdBook.Mapa).To(HaveKeyWithValue("name", bookName))
			Expect(createdBook.Mapa).To(HaveKeyWithValue("authors", []interface{}{authorID}))

			bookID := createdBook.MustGetString("uuid")

			// we can also demonstrate ref resolve functionality - when using assetGet, there is resolve param
			// when resolve == true, then all foreign keys will be replaced by their respective asset instances
			resolvedBook := tctx.Rmap("assetGet", "book", bookID, true, rmap.NewEmpty())

			// you can use MustGetJPtr* methods on rmap to easily get nested values in one go using JSONPointer
			bookAuthorName := resolvedBook.MustGetJPtrString("/authors/0/name")
			Expect(bookAuthorName).To(Equal(authorName))
		})
	})
})
